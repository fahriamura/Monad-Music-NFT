<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music NADS - NFT Music Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.1/ethers.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-section i {
            font-size: 2rem;
            color: #bb86fc;
        }

        .logo-section h1 {
            font-size: 1.8rem;
            color: #bb86fc;
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .wallet-address {
            background: rgba(187, 134, 252, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-family: monospace;
        }

        /* Main Content Grid */
        .main-content {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 30px;
        }

        /* NFT Mint Card */
        .mint-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: transform 0.3s ease;
            height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .mint-card:hover {
            transform: translateY(-5px);
        }

        .mint-card i {
            font-size: 4rem;
            color: #bb86fc;
            margin-bottom: 20px;
        }

        /* Music Player Card */
        .player-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            height: 300px;
            display: flex;
            flex-direction: column;
        }

        .cover-display {
            width: 200px;
            /* height is derived from aspect-ratio to guarantee square */
            aspect-ratio: 1 / 1;
            margin: 0 auto;
            background: #2d2d2d;
            border-radius: 10px;
            overflow: hidden;
        }

        .cover-display img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(187, 134, 252, 0.2);
        }

        .progress-container {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: #bb86fc;
            transition: width 0.1s linear;
        }

        /* Autoplay toggle */
        .autoplay-toggle {
            margin-top: 10px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            user-select: none;
        }
        /* Switch component */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.3);
            transition: 0.4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 3px;
            background-color: #fff;
            transition: 0.4s;
            border-radius: 50%;
        }

        .switch input:checked + .slider {
            background-color: #bb86fc;
        }

        .switch input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Maintain 1:1 aspect ratio for covers */
        .cover-display, .item-cover {
            aspect-ratio: 1 / 1;
        }

        .switch-label {
            margin-left: 8px;
        }

        /* Music List Section */
        .music-list-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
        }

        .list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        .search-bar {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 8px 15px;
            width: 300px;
        }

        .search-bar input {
            background: none;
            border: none;
            color: white;
            width: 100%;
            padding: 5px;
            outline: none;
        }

        .search-bar i {
            color: rgba(255, 255, 255, 0.5);
            margin-right: 10px;
        }

        .music-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 0 10px;
        }

        .music-list::-webkit-scrollbar {
            width: 8px;
        }

        .music-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .music-list::-webkit-scrollbar-thumb {
            background: #bb86fc;
            border-radius: 4px;
        }

        .music-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            transition: background-color 0.3s ease;
        }

        .music-item:hover {
            background: rgba(187, 134, 252, 0.1);
        }

        .item-cover {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            overflow: hidden;
            margin-right: 15px;
        }

        .item-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .item-info {
            flex: 1;
        }

        .item-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .item-artist {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .item-actions {
            display: flex;
            gap: 15px;
        }

        .action-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .action-btn:hover {
            opacity: 1;
            color: #bb86fc;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .modal-content {
            position: relative;
            background: #1a1a1a;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            border: 1px solid rgba(187, 134, 252, 0.2);
        }

        .close-modal {
            position: absolute;
            right: 20px;
            top: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .close-modal:hover {
            opacity: 1;
        }

        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .tab-btn.active {
            background: #bb86fc;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.7);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            outline: none;
        }

        .form-group input:focus,
        .form-group select:focus {
            border-color: #bb86fc;
        }

        .btn {
            background: #bb86fc;
            color: #1a1a1a;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Send NFT Modal */
        .send-modal .form-group input {
            font-family: monospace;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .mint-card, .player-card {
                height: 250px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 20px;
                text-align: center;
            }

            .search-bar {
                width: 100%;
            }

            .music-item {
                flex-direction: column;
                text-align: center;
            }

            .item-cover {
                margin: 0 auto 15px;
            }

            .item-actions {
                margin-top: 15px;
                justify-content: center;
            }
        }

        /* Status Message Styles */
        .status-message {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-weight: 500;
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        .status-message.show {
            display: block;
        }

        .status-message.success {
            background: rgba(46, 125, 50, 0.9);
            border-left: 4px solid #2e7d32;
        }

        .status-message.error {
            background: rgba(211, 47, 47, 0.9);
            border-left: 4px solid #d32f2f;
        }

        .status-message.info {
            background: rgba(2, 136, 209, 0.9);
            border-left: 4px solid #0288d1;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Improved contrast for genre dropdown */
        #genre {
            background: #ffffff;
            color: #000000;
        }

        #genre option {
            background: #ffffff;
            color: #000000;
        }

        #genre option:hover,
        #genre option:focus,
        #genre option:checked {
            background: #000000;
            color: #ffffff;
        }

        /* Footer styling */
        .footer {
            text-align: center;
            margin-top: 40px;
            color: rgba(255, 255, 255, 0.6);
        }

        .footer a {
            color: #bb86fc;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Track Info */
        .track-info {
            text-align: center;
            margin-top: 15px;
        }

        .track-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .track-artist {
            font-size: 0.9rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo-section">
                <i class="fas fa-music"></i>
                <h1>Music NADS</h1>
            </div>
            <div class="wallet-section">
                <div id="walletAddress" class="wallet-address">Not Connected</div>
                <button id="connectWallet" class="btn">Connect Wallet</button>
                <button id="disconnectWallet" class="btn" style="display: none;">Disconnect</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- NFT Mint Card -->
            <div id="mintCard" class="mint-card">
                <i class="fas fa-plus-circle"></i>
                <h2>Mint New Music NFT</h2>
            </div>

            <!-- Music Player Card -->
            <div class="player-card">
                <div class="cover-display">
                    <img id="currentCover" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="No music playing">
                </div>
                <!-- Track information -->
                <div class="track-info">
                    <h3 id="currentTitle" class="track-title">No music playing</h3>
                    <p id="currentArtist" class="track-artist"></p>
                </div>
                <div class="player-controls">
                    <button class="control-btn" id="prevBtn"><i class="fas fa-backward"></i></button>
                    <button class="control-btn" id="playBtn"><i class="fas fa-play"></i></button>
                    <button class="control-btn" id="nextBtn"><i class="fas fa-forward"></i></button>
                </div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress" id="audioProgress"></div>
                    </div>
                </div>
                <!-- Autoplay Switch -->
                <div class="autoplay-toggle">
                    <label class="switch">
                        <input type="checkbox" id="autoplayToggle" checked>
                        <span class="slider"></span>
                    </label>
                    <span class="switch-label">Autoplay</span>
                </div>
            </div>
        </div>

        <!-- Music List Section -->
        <div class="music-list-section">
            <div class="list-header">
                <h2>Your Music Collection</h2>
                <div class="search-bar">
                    <i class="fas fa-search"></i>
                    <input type="text" id="searchInput" placeholder="Search by title or artist...">
                </div>
            </div>
            <div class="music-list" id="musicList">
                <!-- Music items will be added here dynamically -->
            </div>
        </div>

        <!-- Status Message -->
        <div id="statusMessage" class="status-message"></div>

        <!-- Mint Modal -->
        <div id="mintModal" class="modal">
            <div class="modal-content">
                <button class="close-modal">&times;</button>
                <h2>Mint New Music NFT</h2>
                <div class="tab-buttons">
                    <button class="tab-btn active" data-tab="upload">Upload Audio</button>
                    <button class="tab-btn" data-tab="youtube">YouTube to MP3</button>
                </div>
                
                <!-- Upload Audio Form -->
                <div id="uploadForm" class="tab-content">
                    <div class="form-group">
                        <label for="title">Song Title</label>
                        <input type="text" id="title" required>
                    </div>
                    <div class="form-group">
                        <label for="artist">Artist</label>
                        <input type="text" id="artist" required>
                    </div>
                    <div class="form-group">
                        <label for="genre">Genre</label>
                        <select id="genre" required>
                            <option value="">Select Genre</option>
                            <option value="Pop">Pop</option>
                            <option value="Rock">Rock</option>
                            <option value="Hip-Hop">Hip-Hop</option>
                            <option value="Electronic">Electronic</option>
                            <option value="Jazz">Jazz</option>
                            <option value="Classical">Classical</option>
                            <option value="R&B">R&B</option>
                            <option value="Country">Country</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="audioFile">Audio File (MP3)</label>
                        <input type="file" id="audioFile" accept="audio/mp3" required>
                    </div>
                    <div class="form-group">
                        <label for="coverFile">Cover Art (Optional)</label>
                        <input type="file" id="coverFile" accept="image/*">
                    </div>
                    <button id="mintNFT" class="btn">Mint Music NFT (Free)</button>
                </div>

                <!-- YouTube to MP3 Form -->
                <div id="youtubeForm" class="tab-content" style="display: none;">
                    <div class="form-group">
                        <label for="youtubeUrl">YouTube URL</label>
                        <input type="text" id="youtubeUrl" placeholder="https://www.youtube.com/watch?v=...">
                    </div>
                    <button id="convertYoutube" class="btn">Convert to MP3</button>
                    <div id="conversionStatus" style="margin-top: 15px;"></div>
                </div>
            </div>
        </div>

        <!-- Send NFT Modal -->
        <div id="sendModal" class="modal">
            <div class="modal-content">
                <button class="close-modal">&times;</button>
                <h2>Send Music NFT</h2>
                <div class="form-group">
                    <label for="recipientAddress">Recipient Wallet Address</label>
                    <input type="text" id="recipientAddress" placeholder="0x...">
                </div>
                <button id="sendNFT" class="btn">Send NFT</button>
            </div>
        </div>

        <!-- Hidden Audio Player -->
        <audio id="audioPlayer"></audio>
    </div>

    <!-- Footer -->
    <footer class="footer">
        Powered by <a href="https://x.com/absolya227" target="_blank">Absol Lothareclya</a>
    </footer>

    <script>
    window.onload = async function() {
        const loadEnv = async () => {
            // First try window._env_ (injected by Vercel)
            if (window._env_) {
                return window._env_;
            }

            // Then try loading from various env files
            const parseEnvText = (txt) => txt.split('\n').reduce((acc, line) => {
                const [key, ...rest] = line.split('=');
                if (!key || key.startsWith('#')) return acc;
                acc[key.trim()] = rest.join('=')?.trim()?.replace(/^"|"$/g, '');
                return acc;
            }, {});

            const candidates = [
                './.env.json',
                '.env.json',
                './.env',
                '.env',
                '/.env',
                '../.env',
                '/env',
                '../env',
                '/env.json',
                '../env.json'
            ];

            for (const path of candidates) {
                try {
                    const resp = await fetch(path, { cache: 'no-store' });
                    if (resp.ok) {
                        const contentType = resp.headers.get('Content-Type') || '';
                        const text = await resp.text();
                        if (!text.trim()) continue;
                        if (contentType.includes('application/json') || path.endsWith('.json')) {
                            return JSON.parse(text);
                        }
                        return parseEnvText(text);
                    }
                } catch (_) { /* ignore and try next */ }
            }

            // If no env files found, try getting from HTML meta tags
            const envFromMeta = {};
            document.querySelectorAll('meta[name^="env-"]').forEach(meta => {
                const key = meta.getAttribute('name').replace('env-', '');
                envFromMeta[key] = meta.getAttribute('content');
            });
            if (Object.keys(envFromMeta).length) {
                return envFromMeta;
            }

            return {};
        };

        const ENV = await loadEnv();
        
        // Use environment variables with fallbacks
        const DID_TOKEN = ENV.DID_TOKEN || ENV.NEXT_PUBLIC_DID_TOKEN || '';
        const PINATA_JWT = ENV.PINATA_JWT || ENV.NEXT_PUBLIC_PINATA_JWT || '';
        const CONTRACT_ADDRESS = ENV.CONTRACT_ADDRESS || ENV.NEXT_PUBLIC_CONTRACT_ADDRESS || '';

        // Only show warning if we're not in production
        if ((!DID_TOKEN || !CONTRACT_ADDRESS || !PINATA_JWT) && window.location.hostname === 'localhost') {
            console.warn('Some environment variables are missing. Please check your configuration.');
            showStatus('Please configure your environment variables in .env or .env.json', 'info');
        }
        
        // Web3.Storage alternative - menggunakan Pinata sebagai backup
        const PINATA_GATEWAY = "https://gateway.pinata.cloud/ipfs/";
        const PINATA_API_ENDPOINT = "https://api.pinata.cloud/pinning/pinFileToIPFS";
        
        const MONAD_TESTNET_CONFIG = {
            chainId: '0x279F', 
            chainName: 'Monad Testnet',
            nativeCurrency: {
                name: 'MON',
                symbol: 'MON',
                decimals: 18
            },
            rpcUrls: ['https://testnet-rpc.monad.xyz'],
            blockExplorerUrls: ['https://testnet.monadexplorer.com']
        };

        const CONTRACT_ABI = [
            "function mintMusicNFT(address to, string memory title, string memory artist, string memory genre, uint256 duration, string memory audioIPFSHash, string memory coverIPFSHash, string memory tokenURI) public payable",
            "function getUserTokens(address user) view returns (uint256[])",
            "function getMusicData(uint256 tokenId) public view returns (tuple(string title, string artist, string genre, uint256 duration, string audioIPFSHash, string coverIPFSHash, uint256 mintedAt, bool isActive))",
            "function playMusic(uint256 tokenId) public",
            "function mintPrice() public view returns (uint256)",
            "function totalSupply() public view returns (uint256)",
            "function burnNFT(uint256 tokenId) public",
            "function duplicateTransfer(address to, uint256 tokenId) public"
        ];

        let web3Provider = null;
        let walletSigner = null;
        let musicContract = null;
        let readOnlyContract = null;
        let currentAudio = null;
        let userAddress = '';

        // Playlist handling
        let playlist = [];
        let currentIndex = -1;
        let autoplayEnabled = true;

        // Player control elements
        const prevBtn = document.getElementById('prevBtn');
        const playControlBtn = document.getElementById('playBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.querySelector('.progress-bar');
        const autoplayToggle = document.getElementById('autoplayToggle');

        // Attach control listeners
        if (prevBtn) prevBtn.addEventListener('click', playPrev);
        if (playControlBtn) playControlBtn.addEventListener('click', togglePlayPause);
        if (nextBtn) nextBtn.addEventListener('click', playNext);
        if (progressBar) progressBar.addEventListener('click', seekAudio);
        if (autoplayToggle) autoplayToggle.addEventListener('change', () => {
            autoplayEnabled = autoplayToggle.checked;
        });

        const connectWalletBtn = document.getElementById('connectWallet');
        const disconnectWalletBtn = document.getElementById('disconnectWallet');
        const walletAddress = document.getElementById('walletAddress');
        const musicList = document.getElementById('musicList');
        const mintModal = document.getElementById('mintModal');
        const sendModal = document.getElementById('sendModal');
        const audioPlayer = document.getElementById('audioPlayer');

        // Event listeners
        connectWalletBtn.addEventListener('click', connectWallet);
        disconnectWalletBtn.addEventListener('click', disconnectWallet);

        // Initialize UI event listeners immediately after page load
        {
            // Search functionality
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const musicItems = document.querySelectorAll('.music-item');
                    
                    musicItems.forEach(item => {
                        const title = item.querySelector('.item-title').textContent.toLowerCase();
                        const artist = item.querySelector('.item-artist').textContent.toLowerCase();
                        
                        item.style.display = (title.includes(searchTerm) || artist.includes(searchTerm)) ? 'flex' : 'none';
                    });
                });
            }

            // Mint card click
            const mintCard = document.getElementById('mintCard');
            const mintModal = document.getElementById('mintModal');
            const mintNFTBtn = document.getElementById('mintNFT');
            const sendModal = document.getElementById('sendModal');

            // Mint card click handler
            if (mintCard) {
                mintCard.addEventListener('click', () => {
                    if (!userAddress) {
                        showStatus('Please connect your wallet first', 'error');
                        return;
                    }
                    if (mintModal) {
                        mintModal.style.display = 'block';
                    }
                });
            }

            // Close buttons for all modals
            const closeButtons = document.querySelectorAll('.close-modal');
            closeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const modal = button.closest('.modal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
            });

            // Close modal when clicking outside
            window.addEventListener('click', (event) => {
                if (event.target.classList.contains('modal')) {
                    event.target.style.display = 'none';
                }
            });

            // Tab switching in mint modal
            const tabButtons = document.querySelectorAll('.tab-btn');
            tabButtons.forEach(button => {
                button.onclick = () => {
                    const tab = button.getAttribute('data-tab');
                    
                    // Update active button
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Show/hide content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.style.display = content.id === `${tab}Form` ? 'block' : 'none';
                    });
                };
            });

            // Convert YouTube button
            const convertBtn = document.getElementById('convertYoutube');
            if (convertBtn) {
                convertBtn.onclick = convertYoutubeToMp3;
            }

            // Send NFT button in modal
            const sendNFTBtn = document.getElementById('sendNFT');
            if (sendNFTBtn) {
                sendNFTBtn.onclick = sendNFT;
            }

            // Mint NFT button click handler
            if (mintNFTBtn) {
                mintNFTBtn.addEventListener('click', mintMusicNFT);
            }
        }

        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showStatus('Please install MetaMask to continue!', 'error');
                    return;
                }
                web3Provider = new ethers.BrowserProvider(window.ethereum);
                const accounts = await web3Provider.send("eth_requestAccounts", []);
                walletSigner = await web3Provider.getSigner();
                userAddress = accounts[0];
                walletAddress.textContent = `Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                walletAddress.classList.remove('hidden');
                connectWalletBtn.textContent = 'Connected';
                connectWalletBtn.disabled = true;
                
                // Check network
                const network = await web3Provider.getNetwork();
                if (network.chainId !== 10143n) { // Monad Testnet chainId
                    showStatus('Please switch to Monad Testnet', 'info');
                } else {
                    initializeContract();
                }
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showStatus('Error connecting wallet: ' + error.message, 'error');
            }
        }

        async function disconnectWallet() {
            try {
                walletAddress.textContent = 'Not Connected';
                walletAddress.classList.add('hidden');
                connectWalletBtn.textContent = 'Connect Wallet';
                connectWalletBtn.disabled = false;
                disconnectWalletBtn.style.display = 'none';
                currentAudio = null;
                musicList.innerHTML = '';
                showStatus('Wallet disconnected', 'info');
            } catch (error) {
                console.error('Error disconnecting wallet:', error);
                showStatus('Error disconnecting wallet: ' + error.message, 'error');
            }
        }

        async function initializeContract() {
            try {
                const customProvider = new ethers.JsonRpcProvider('https://testnet-rpc.monad.xyz', {
                    chainId: 10143,
                    name: 'Monad Testnet',
                    ensAddress: null 
                });
                readOnlyContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, customProvider);
                musicContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, walletSigner);
                await loadUserMusic();
                showStatus('Successfully connected to Monad Music NFT!', 'success');
            } catch (error) {
                console.error('Error initializing contract:', error);
                showStatus('Error initializing contract. Make sure contract is deployed.', 'error');
            }
        }

        async function loadUserMusic() {
            try {
                if (!userAddress || !ethers.isAddress(userAddress)) {
                    showStatus('Invalid user address', 'error');
                    return;
                }
                console.log('Loading music for user:', userAddress);
                const tokenIds = await readOnlyContract.getUserTokens(userAddress);
                // Prepare playlist (convert BigInt to Number for easier handling)
                playlist = tokenIds.map(id => Number(id));
                musicList.innerHTML = '';
                
                for (let tokenId of tokenIds) {
                    const musicData = await readOnlyContract.getMusicData(tokenId);
                    createMusicCard(tokenId, musicData);
                }
                
                if (tokenIds.length === 0) {
                    musicList.innerHTML = '<p style="text-align: center; grid-column: 1/-1; opacity: 0.7;">No music NFTs found. Mint your first one below! ðŸŽµ</p>';
                }
            } catch (error) {
                console.error('Error loading user music:', error);
                showStatus('Error loading music collection: ' + error.message, 'error');
            }
        }

        function createMusicCard(tokenId, musicData) {
            const card = document.createElement('div');
            card.className = 'music-item';
            
            const ipfsGateway = 'https://ipfs.io/ipfs/';
            const coverUrl = musicData.coverIPFSHash ? 
                `${ipfsGateway}${musicData.coverIPFSHash}` : '';
            
            card.innerHTML = `
                <div class="item-cover">
                    ${coverUrl ? 
                        `<img src="${coverUrl}" alt="Cover Art" onerror="this.style.display='none'; this.parentElement.innerHTML='ðŸŽµ';">` : 
                        'ðŸŽµ'
                    }
                </div>
                <div class="item-info">
                    <h3 class="item-title">${musicData.title}</h3>
                    <p class="item-artist">${musicData.artist}</p>
                </div>
                <div class="item-actions">
                    <button class="action-btn play-btn" onclick="playMusic(${tokenId}, '${musicData.audioIPFSHash}', this)" title="Play">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="action-btn send-btn" onclick="openSendModal(${tokenId})" title="Send to Address">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button class="action-btn delete-btn" onclick="burnNFT(${tokenId})" title="Delete NFT">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            musicList.appendChild(card);
        }

        async function playMusic(tokenId, audioIPFSHash, button, skipTx = false) {
            try {
                if (!userAddress) {
                    throw new Error('Please connect your wallet first');
                }

                // Update current index within playlist
                const idx = playlist.indexOf(Number(tokenId));
                if (idx !== -1) currentIndex = idx;

                if (currentAudio && !currentAudio.paused) {
                    currentAudio.pause();
                    document.querySelectorAll('.play-btn i').forEach(btn => {
                        btn.className = 'fas fa-play';
                    });
                    if (currentAudio.src.includes(audioIPFSHash)) {
                        currentAudio = null;
                        return;
                    }
                }

                // Call contract playMusic function (skip during autoplay to avoid signing)
                if (!skipTx) {
                    try {
                        const tx = await musicContract.playMusic(tokenId);
                        await tx.wait();
                        console.log('Blockchain play event recorded');
                    } catch (contractError) {
                        console.log('playMusic tx failed (possibly rejected) â€“ continuing playback:', contractError);
                    }
                }

                // Play audio
                const audioUrl = `https://ipfs.io/ipfs/${audioIPFSHash}`;
                audioPlayer.src = audioUrl;
                await audioPlayer.play();
                currentAudio = audioPlayer;

                // Update UI
                document.querySelectorAll('.play-btn i').forEach(btn => {
                    btn.className = 'fas fa-play';
                });
                if (button) button.querySelector('i').className = 'fas fa-pause';
                // Update central control icon
                if (playControlBtn) playControlBtn.querySelector('i').className = 'fas fa-pause';

                // Update player display
                const musicData = await musicContract.getMusicData(tokenId);
                const coverUrl = musicData.coverIPFSHash ? 
                    `https://ipfs.io/ipfs/${musicData.coverIPFSHash}` : 
                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                
                document.getElementById('currentCover').src = coverUrl;

                // Update title & artist in player card
                const titleElem = document.getElementById('currentTitle');
                const artistElem = document.getElementById('currentArtist');
                if (titleElem) titleElem.textContent = musicData.title;
                if (artistElem) artistElem.textContent = musicData.artist;

                // Event listeners for audio player
                audioPlayer.onended = () => {
                    if (button) button.querySelector('i').className = 'fas fa-play';
                    if (playControlBtn) playControlBtn.querySelector('i').className = 'fas fa-play';
                    currentAudio = null;
                    // Auto play next track if enabled
                    if (autoplayEnabled) {
                        playNext(true);
                    }
                };

                audioPlayer.onpause = () => {
                    if (button) button.querySelector('i').className = 'fas fa-play';
                    if (playControlBtn) playControlBtn.querySelector('i').className = 'fas fa-play';
                };

                audioPlayer.onplay = () => {
                    if (button) button.querySelector('i').className = 'fas fa-pause';
                    if (playControlBtn) playControlBtn.querySelector('i').className = 'fas fa-pause';
                };

                // Update progress bar
                audioPlayer.ontimeupdate = () => {
                    if (audioPlayer.duration) {
                        const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                        document.getElementById('audioProgress').style.width = progress + '%';
                    }
                };

            } catch (error) {
                console.error('Error playing music:', error);
                showStatus('Error playing music: ' + error.message, 'error');
            }
        }

        // Simplified IPFS upload using Pinata with a fallback when MetaMask (or other) fetch polyfill
        // cannot handle FormData (DataCloneError). We try fetch first, then fall back to XMLHttpRequest.
        async function uploadToPinata(file) {
            showStatus(`Uploading ${file.name} to Pinata...`, 'info');
            const formData = new FormData();
            formData.append('file', file);

            // Helper that actually parses Pinata response and throws on error
            const parsePinataResponse = async (resp) => {
                if (!resp || resp.status !== 200) {
                    const status = resp ? `${resp.status} ${resp.statusText}` : 'No response';
                    throw new Error(`Pinata upload failed: ${status}`);
                }
                let json;
                try {
                    json = typeof resp.json === 'function' ? await resp.json() : JSON.parse(resp.responseText);
                } catch (e) {
                    throw new Error('Invalid Pinata response');
                }
                if (!json.IpfsHash) {
                    throw new Error('Invalid Pinata response');
                }
                return json.IpfsHash;
            };

            // Attempt 1: native fetch (might fail due to FormData cloning issue)
            try {
                const resp = await window.fetch(PINATA_API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${PINATA_JWT}`
                    },
                    body: formData,
                    mode: 'cors'
                });
                return await parsePinataResponse(resp);
            } catch (err) {
                console.warn('Fetch upload failed, trying XMLHttpRequest...', err);
            }

            // Attempt 2: XMLHttpRequest fallback (avoids structuredClone on FormData)
            return await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', PINATA_API_ENDPOINT, true);
                xhr.setRequestHeader('Authorization', `Bearer ${PINATA_JWT}`);
                xhr.onreadystatechange = async function () {
                    if (xhr.readyState === 4) {
                        try {
                            const hash = await parsePinataResponse(xhr);
                            resolve(hash);
                        } catch (e) {
                            reject(e);
                        }
                    }
                };
                xhr.onerror = () => reject(new Error('Network error uploading to Pinata via XHR'));
                xhr.send(formData);
            });
        }

        // Crop an image file to a centered 1:1 square before uploading
        function cropImageToSquare(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const size = Math.min(img.width, img.height);
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    const sx = (img.width - size) / 2;
                    const sy = (img.height - size) / 2;
                    ctx.drawImage(img, sx, sy, size, size, 0, 0, size, size);
                    canvas.toBlob(blob => {
                        if (!blob) {
                            reject(new Error('Unable to crop image'));
                            return;
                        }
                        const croppedFile = new File([blob], `cropped_${file.name}`, { type: 'image/png' });
                        resolve(croppedFile);
                    }, 'image/png');
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        // Function to get audio duration
        function getAudioDuration(file) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.addEventListener('loadedmetadata', () => {
                    resolve(Math.ceil(audio.duration));
                });
                audio.addEventListener('error', reject);
                audio.src = URL.createObjectURL(file);
            });
        }

        async function mintMusicNFT() {
            const mintButton = document.getElementById('mintNFT');
            try {
                if (!userAddress) {
                    throw new Error('Please connect your wallet first');
                }

                const title = document.getElementById('title').value;
                const artist = document.getElementById('artist').value;
                const genre = document.getElementById('genre').value;
                const audioFile = document.getElementById('audioFile').files[0];
                const coverFile = document.getElementById('coverFile').files[0];
                
                if (!title || !artist || !genre || !audioFile) {
                    throw new Error('Please fill in all required fields');
                }

                if (!audioFile.type.startsWith('audio/')) {
                    throw new Error('Please upload a valid audio file');
                }

                if (coverFile && !coverFile.type.startsWith('image/')) {
                    throw new Error('Cover art must be an image file');
                }

                mintButton.disabled = true;
                mintButton.textContent = 'Minting...';
                
                showStatus('Uploading files to IPFS via Pinata...', 'info');

                // Upload audio to Pinata and get its IPFS hash
                const audioIPFSHash = await uploadToPinata(audioFile);
                console.log('Audio uploaded to Pinata:', audioIPFSHash);

                // Calculate audio duration in seconds (rounded up)
                const durationSeconds = await getAudioDuration(audioFile);
                console.log('Audio duration (s):', durationSeconds);

                // Upload cover art if provided
                let coverIPFSHash = '';
                if (coverFile) {
                    // Crop to 1:1 before uploading
                    const croppedCover = await cropImageToSquare(coverFile);
                    coverIPFSHash = await uploadToPinata(croppedCover);
                    console.log('Cover uploaded to Pinata:', coverIPFSHash);
                }

                // Upload metadata JSON
                const metadata = {
                    title,
                    artist,
                    genre,
                    duration: durationSeconds,
                    audioUrl: `ipfs://${audioIPFSHash}`,
                    coverUrl: coverIPFSHash ? `ipfs://${coverIPFSHash}` : '',
                    did_token: DID_TOKEN,
                    attributes: [
                        { trait_type: 'Title', value: title },
                        { trait_type: 'Artist', value: artist },
                        { trait_type: 'Genre', value: genre },
                        { trait_type: 'Duration', value: durationSeconds }
                    ]
                };

                const metadataBlob = new Blob([JSON.stringify(metadata)], { type: 'application/json' });
                const metadataFile = new File([metadataBlob], 'metadata.json');
                const metadataIPFSHash = await uploadToPinata(metadataFile);
                
                showStatus('Minting NFT on Monad blockchain...', 'info');
                const mintPrice = await readOnlyContract.mintPrice();
                
                const tx = await musicContract.mintMusicNFT(
                    userAddress,
                    title,
                    artist,
                    genre,
                    durationSeconds,
                    audioIPFSHash,
                    coverIPFSHash,
                    `ipfs://${metadataIPFSHash}`,
                    { value: mintPrice }
                );
                
                await tx.wait();
                showStatus('Music NFT minted successfully!', 'success');
                
                // Clear form and close modal
                document.getElementById('title').value = '';
                document.getElementById('artist').value = '';
                document.getElementById('genre').value = '';
                document.getElementById('audioFile').value = '';
                document.getElementById('coverFile').value = '';
                document.getElementById('mintModal').style.display = 'none';
                
                // Refresh music list
                await loadUserMusic();
                
            } catch (error) {
                console.error('Error minting NFT:', error);
                showStatus('Error minting NFT: ' + error.message, 'error');
            } finally {
                if (mintButton) {
                    mintButton.disabled = false;
                    mintButton.textContent = 'Mint Music NFT (Free)';
                }
            }
        }

        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('statusMessage');
            if (!statusElement) {
                console.warn('Status element not found');
                return;
            }

            // Remove existing classes
            statusElement.className = 'status-message';
            
            // Add new classes
            statusElement.classList.add('show', type);
            statusElement.textContent = message;

            // Auto hide after 5 seconds
            setTimeout(() => {
                statusElement.classList.remove('show');
            }, 5000);
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Check if wallet is already connected
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.request({ method: 'eth_accounts' })
                .then(accounts => {
                    if (accounts.length > 0) {
                        connectWallet();
                    }
                })
                .catch(error => {
                    console.error('Error checking existing accounts:', error);
                });
        }

        // Log DID token on startup
        console.log('DID Token initialized:', DID_TOKEN);

        // Add these new functions for handling actions
        async function burnNFT(tokenId) {
            try {
                if (!userAddress) {
                    throw new Error('Please connect your wallet first');
                }

                if (!confirm('Are you sure you want to burn this NFT? This action cannot be undone.')) {
                    return;
                }
                
                showStatus('Burning NFT...', 'info');
                const tx = await musicContract.burnNFT(tokenId);
                await tx.wait();
                
                showStatus('NFT burned successfully!', 'success');
                await loadUserMusic(); // Refresh the list
            } catch (error) {
                console.error('Error burning NFT:', error);
                showStatus('Error burning NFT: ' + error.message, 'error');
            }
        }

        function openSendModal(tokenId) {
            const sendModal = document.getElementById('sendModal');
            if (sendModal) {
                sendModal.dataset.tokenId = tokenId;
                sendModal.style.display = 'block';
            }
        }

        async function sendNFT() {
            try {
                if (!userAddress) {
                    throw new Error('Please connect your wallet first');
                }

                const sendModal = document.getElementById('sendModal');
                const tokenId = sendModal.dataset.tokenId;
                const recipientAddress = document.getElementById('recipientAddress').value;

                if (!ethers.isAddress(recipientAddress)) {
                    throw new Error('Invalid recipient address');
                }

                const sendButton = document.getElementById('sendNFT');
                sendButton.disabled = true;
                showStatus('Sending NFT...', 'info');

                const tx = await musicContract.duplicateTransfer(recipientAddress, tokenId);
                await tx.wait();

                showStatus('NFT sent successfully!', 'success');
                sendModal.style.display = 'none';
                document.getElementById('recipientAddress').value = '';
                await loadUserMusic(); // Refresh the list
            } catch (error) {
                console.error('Error sending NFT:', error);
                showStatus('Error sending NFT: ' + error.message, 'error');
            } finally {
                const sendButton = document.getElementById('sendNFT');
                sendButton.disabled = false;
            }
        }

        // Updated YouTube to MP3 conversion
        async function convertYoutubeToMp3() {
            const youtubeUrl = document.getElementById('youtubeUrl').value.trim();
            const conversionStatus = document.getElementById('conversionStatus');
            const convertButton = document.getElementById('convertYoutube');

            if (!youtubeUrl) {
                conversionStatus.innerHTML = '<p style="color: red;">Please enter a YouTube URL</p>';
                return;
            }

            try {
                convertButton.disabled = true;
                conversionStatus.innerHTML = '<p>Converting... Please wait</p>';

                const apiUrl = `https://absollothareclya-18caaaa7ce95.herokuapp.com/convert.php?youtubelink=${encodeURIComponent(youtubeUrl)}&format=mp3`;
                const response = await fetch(apiUrl);

                if (!response.ok) {
                    throw new Error(`Conversion request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error || !data.file) {
                    throw new Error('Conversion failed on server');
                }

                // Download the converted MP3 file
                const mp3Response = await fetch(data.file);
                if (!mp3Response.ok) {
                    throw new Error('Failed to download converted MP3 file');
                }

                const mp3Blob = await mp3Response.blob();

                const safeTitle = (data.title || 'Track').replace(/[^a-z0-9\- _]/gi, '_');
                const mp3File = new File([mp3Blob], `${safeTitle}.mp3`, { type: 'audio/mp3' });

                // Auto-populate form fields
                document.getElementById('title').value = data.title || safeTitle;
                document.getElementById('artist').value = 'Unknown';

                const audioFileInput = document.getElementById('audioFile');
                const dt = new DataTransfer();
                dt.items.add(mp3File);
                audioFileInput.files = dt.files;

                // Switch back to the upload tab
                document.querySelector('[data-tab="upload"]').click();
                conversionStatus.innerHTML = '<p style="color: green;">Conversion successful! You can now mint the NFT.</p>';
            } catch (error) {
                console.error('Conversion error:', error);
                conversionStatus.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            } finally {
                convertButton.disabled = false;
            }
        }

        //-------------------------------
        //  Extra Player Controls
        //-------------------------------

        function togglePlayPause() {
            if (!currentAudio) return;
            if (currentAudio.paused) {
                currentAudio.play();
            } else {
                currentAudio.pause();
            }
        }

        function playByIndex(index, skipTx = false) {
            if (!playlist.length) return;
            if (index < 0) index = playlist.length - 1;
            if (index >= playlist.length) index = 0;
            const tokenId = playlist[index];
            currentIndex = index;
            readOnlyContract.getMusicData(tokenId).then(musicData => {
                playMusic(tokenId, musicData.audioIPFSHash, null, skipTx);
            }).catch(err => console.error('playByIndex error', err));
        }

        function playNext(skipTx = false) {
            playByIndex(currentIndex + 1, skipTx);
        }

        function playPrev(skipTx = false) {
            playByIndex(currentIndex - 1, skipTx);
        }

        function seekAudio(e) {
            if (!audioPlayer || !audioPlayer.duration) return;
            const rect = progressBar.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            audioPlayer.currentTime = percentage * audioPlayer.duration;
        }

        // Make functions globally accessible
        window.playMusic = playMusic;
        window.burnNFT = burnNFT;
        window.openSendModal = openSendModal;
        window.sendNFT = sendNFT;
        window.mintMusicNFT = mintMusicNFT;
        window.convertYoutubeToMp3 = convertYoutubeToMp3;
    };
    </script>
</body>
</html>